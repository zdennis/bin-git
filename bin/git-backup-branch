#!/usr/bin/env ruby

require 'optparse'
require 'date'
require 'shellwords'

VERSION = "1.1.0"
SCRIPT_NAME = File.basename(__FILE__)

def require_or_install(name, version:, require_as: name)
  require require_as
rescue LoadError => ex
  begin
    puts "Missing gem #{name}. Installing #{name} #{version}..."
    system "gem install #{name} -v #{version}"
    Gem.refresh
    require require_as
  rescue => ex
    puts ex
    puts "#{name} #{version} could not be installed. You will need to install it manually."
    exit 1
  end
end

require_or_install 'term-ansicolor', version: '1.7.1', require_as: 'term/ansicolor'

$quiet = false

def info(message)
  puts message unless $quiet
end

def current_branch
  `git rev-parse --abbrev-ref HEAD`.chomp
end

def main_branch
  # Try common main branch names in order of preference
  %w[main master].each do |name|
    return name if system("git show-ref --verify --quiet refs/heads/#{Shellwords.escape(name)}")
  end
  # Fall back to checking remote default branch
  remote_head = `git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null`.chomp
  return remote_head.sub(%r{^refs/remotes/origin/}, '') unless remote_head.empty?
  # Default fallback
  'main'
end

options = {
  list: false,
  all: false,
  remote: nil,
  tag: nil,
  restore: false,
  force: false,
  delete: false,
  older_than: nil,
  diff: false,
  quiet: false
}
OptionParser.new do |opts|
  opts.banner = "Usage: #{SCRIPT_NAME} [options] [branch-name]"

  opts.on("-t=TAG", "--tag=TAG", "Tags the backup with a description that is appended to the branch name") do |tag|
    options[:tag] = ".#{tag.strip.downcase.gsub(/\s+/, '-')}"
  end

  opts.on("-l", "--list", "Lists backup branches for current or specified branch") do
    options[:list] = true
  end

  opts.on("-a", "--all", "List all backup branches in the repository (use with --list)") do
    options[:all] = true
  end

  opts.on("-r", "--remote", "Use the remote branch instead of the local branch.") do
    options[:remote] = "origin"
  end

  opts.on("--restore", "Restore a branch from a backup") do
    options[:restore] = true
  end

  opts.on("-f", "--force", "Force restore even if branch has changes (use with --restore)") do
    options[:force] = true
  end

  opts.on("-d", "--delete", "Delete backup branches") do
    options[:delete] = true
  end

  opts.on("--older-than=DAYS", Integer, "Delete backups older than N days (use with --delete)") do |days|
    options[:older_than] = days
  end

  opts.on("--diff", "Show commits between current branch and a backup") do
    options[:diff] = true
  end

  opts.on("-q", "--quiet", "Suppress informational output (errors still shown)") do
    options[:quiet] = true
  end

  opts.on("-v", "--version", "Show version information") do
    puts "#{SCRIPT_NAME} version #{VERSION}"
    exit 0
  end

  opts.on("-h", "--help", "Prints help message") do
    main_branch_name = main_branch

    puts <<~HELP
      #{SCRIPT_NAME} is used to create or list backup branches. It will use the current branch if no branch name
      is provided otherwise it will use the branch name provided.

      Examples:

        #{Term::ANSIColor.bold("# Backup current branch")}
        #{SCRIPT_NAME}

        #{Term::ANSIColor.bold("# Backup specific branch")}
        #{SCRIPT_NAME} features/sign-up

        #{Term::ANSIColor.bold("# Backup the remote branch for the current branch")}
        #{SCRIPT_NAME} -r

        #{Term::ANSIColor.bold("# Backup the remote branch for a specific branch")}
        #{SCRIPT_NAME} -r features/sign-up

        #{Term::ANSIColor.bold("# Backup a branch and tag it with an extra descriptor")}
        #{SCRIPT_NAME} -t "before #{main_branch_name} rebase"

        #{Term::ANSIColor.bold("# List all known backup branches for the current branch")}
        #{SCRIPT_NAME} -l

        #{Term::ANSIColor.bold("# List all known backup branches for a specific branch")}
        #{SCRIPT_NAME} -l features/sign-up

        #{Term::ANSIColor.bold("# List all backup branches in the repository")}
        #{SCRIPT_NAME} -l --all

        #{Term::ANSIColor.bold("# Restore current branch from most recent backup")}
        #{SCRIPT_NAME} --restore

        #{Term::ANSIColor.bold("# Restore a specific branch from its backup")}
        #{SCRIPT_NAME} --restore features/sign-up

        #{Term::ANSIColor.bold("# Force restore (overwrites uncommitted changes)")}
        #{SCRIPT_NAME} --restore --force

        #{Term::ANSIColor.bold("# Delete all backups for current branch")}
        #{SCRIPT_NAME} --delete

        #{Term::ANSIColor.bold("# Delete backups older than 30 days")}
        #{SCRIPT_NAME} --delete --older-than=30

        #{Term::ANSIColor.bold("# Delete backups for a specific branch")}
        #{SCRIPT_NAME} --delete features/sign-up

        #{Term::ANSIColor.bold("# Show commits since last backup")}
        #{SCRIPT_NAME} --diff

        #{Term::ANSIColor.bold("# Show diff for a specific branch")}
        #{SCRIPT_NAME} --diff features/sign-up
    HELP
    puts
    puts opts
    exit
  end
end.parse!

$quiet = options[:quiet]

branch = ARGV.shift || current_branch
todays_date = Date.today.to_s

if branch.to_s.empty?
  STDERR.puts Term::ANSIColor.red <<~ERROR.chomp
    The branch name to backup could not be determined. Please provide the specific branch
    name. See #{SCRIPT_NAME} --help for more information.
  ERROR
  exit 1
end

def branch_exists?(name)
  # Use git show-ref for exact matching instead of grep which can match substrings
  system("git show-ref --verify --quiet refs/heads/#{Shellwords.escape(name)}")
end

def remote_branch_exists?(remote, branch)
  system("git show-ref --verify --quiet refs/remotes/#{Shellwords.escape(remote)}/#{Shellwords.escape(branch)}")
end

def source_exists?(source, remote: nil)
  if remote
    remote_branch_exists?(remote, source)
  else
    branch_exists?(source)
  end
end

def find_backups(branch)
  `git branch`.lines
    .map { |b| b.strip.sub(/^\* /, '') }
    .select { |b| b.start_with?("#{branch}.bak") }
    .sort
end

def extract_date_from_backup(backup_name)
  # Extract date in YYYY-MM-DD format from backup name
  match = backup_name.match(/\.(\d{4}-\d{2}-\d{2})/)
  match ? Date.parse(match[1]) : nil
rescue ArgumentError
  nil
end

def commit_count(branch_name)
  `git rev-list --count #{Shellwords.escape(branch_name)} 2>/dev/null`.chomp.to_i
end

if options.fetch(:list)
  if options[:all]
    # Show all backup branches in the repository
    backup_branches = `git branch -a`.lines.grep(/\.bak/)
  else
    # Show backup branches for the specific branch
    backup_branches = `git branch -a`.lines.grep(/#{Regexp.escape(branch)}\.bak/)
  end

  backup_names = backup_branches.map { |b| b.strip.sub(/^\* /, '') }

  if backup_names.empty?
    # No output needed for empty list
  elsif $quiet
    # In quiet mode, just output branch names
    puts backup_names
  else
    # Show branch names with commit counts
    backup_names.each do |name|
      # Strip remote prefix for display purposes
      display_name = name.sub(%r{^remotes/}, '')
      count = commit_count(name)
      puts "#{display_name} (#{count} commits)"
    end
  end
  exit 0
end

if options.fetch(:delete)
  backups = find_backups(branch)

  if backups.empty?
    STDERR.puts Term::ANSIColor.yellow <<~MESSAGE.chomp
      No backups found for branch '#{branch}'.
    MESSAGE
    exit 0
  end

  # Filter by age if --older-than is specified
  if options[:older_than]
    cutoff_date = Date.today - options[:older_than]
    backups = backups.select do |b|
      date = extract_date_from_backup(b)
      date && date < cutoff_date
    end

    if backups.empty?
      info "No backups older than #{options[:older_than]} days found for '#{branch}'."
      exit 0
    end
  end

  info "The following backup(s) will be deleted:"
  backups.each { |b| info "  #{b}" }

  unless options[:force]
    print "\nAre you sure you want to delete these backups? [y/N]: " unless $quiet
    confirm = $quiet ? 'n' : STDIN.gets&.chomp&.downcase
    unless confirm == 'y' || confirm == 'yes'
      info "Aborted."
      exit 0
    end
  end

  deleted = 0
  failed = 0
  backups.each do |backup|
    if system("git branch -D #{Shellwords.escape(backup)} > /dev/null 2>&1")
      info Term::ANSIColor.green("Deleted #{backup}")
      deleted += 1
    else
      STDERR.puts Term::ANSIColor.red("Failed to delete #{backup}")
      failed += 1
    end
  end

  info "\nDeleted #{deleted} backup(s)#{failed > 0 ? ", #{failed} failed" : ""}."
  exit(failed > 0 ? 1 : 0)
end

if options.fetch(:diff)
  backups = find_backups(branch)

  if backups.empty?
    STDERR.puts Term::ANSIColor.red <<~ERROR.chomp
      No backups found for branch '#{branch}'.
      Use '#{SCRIPT_NAME} -l #{branch}' to list available backups.
    ERROR
    exit 1
  end

  # Use the most recent backup by default
  backup_to_diff = backups.last

  if backups.length > 1
    puts "Multiple backups found for '#{branch}':"
    backups.each_with_index do |b, i|
      puts "  #{i + 1}. #{b}"
    end
    print "\nSelect backup to compare (1-#{backups.length}) [#{backups.length}]: "
    choice = STDIN.gets&.chomp
    choice = backups.length.to_s if choice.nil? || choice.empty?

    index = choice.to_i - 1
    if index < 0 || index >= backups.length
      STDERR.puts Term::ANSIColor.red("Invalid selection")
      exit 1
    end
    backup_to_diff = backups[index]
  end

  # Show commits between backup and current branch
  puts Term::ANSIColor.bold("Commits since #{backup_to_diff}:")
  puts

  commits = `git log --oneline #{Shellwords.escape(backup_to_diff)}..#{Shellwords.escape(branch)} 2>/dev/null`.chomp

  if commits.empty?
    puts Term::ANSIColor.bright_black("  No commits since backup (branches are identical)")
  else
    puts commits
  end

  puts
  puts Term::ANSIColor.bold("Summary:")
  stats = `git diff --stat #{Shellwords.escape(backup_to_diff)}..#{Shellwords.escape(branch)} 2>/dev/null`.chomp

  if stats.empty?
    puts Term::ANSIColor.bright_black("  No changes")
  else
    puts stats
  end

  exit 0
end

if options.fetch(:restore)
  backups = find_backups(branch)

  if backups.empty?
    STDERR.puts Term::ANSIColor.red <<~ERROR.chomp
      No backups found for branch '#{branch}'.
      Use '#{SCRIPT_NAME} -l #{branch}' to list available backups.
    ERROR
    exit 1
  end

  # Use the most recent backup (last in sorted list)
  backup_to_restore = backups.last

  if backups.length > 1 && !$quiet
    puts "Multiple backups found for '#{branch}':"
    backups.each_with_index do |b, i|
      puts "  #{i + 1}. #{b}"
    end
    print "\nSelect backup to restore (1-#{backups.length}) [#{backups.length}]: "
    choice = STDIN.gets&.chomp
    choice = backups.length.to_s if choice.nil? || choice.empty?

    index = choice.to_i - 1
    if index < 0 || index >= backups.length
      STDERR.puts Term::ANSIColor.red("Invalid selection")
      exit 1
    end
    backup_to_restore = backups[index]
  end

  # Check if we're on the branch we're restoring
  on_target_branch = current_branch == branch

  if on_target_branch && !options[:force]
    # Check for uncommitted changes
    status = `git status --porcelain`
    unless status.empty?
      STDERR.puts Term::ANSIColor.red <<~ERROR.chomp
        Branch '#{branch}' has uncommitted changes.
        Commit or stash your changes, or use --force to discard them.
      ERROR
      exit 1
    end
  end

  if on_target_branch
    # Reset current branch to the backup
    command = "git reset --hard #{Shellwords.escape(backup_to_restore)}"
  else
    # Move the branch pointer to the backup
    force_flag = options[:force] ? " -f" : ""
    command = "git branch#{force_flag} #{Shellwords.escape(branch)} #{Shellwords.escape(backup_to_restore)}"
  end

  info command
  if system(command)
    info Term::ANSIColor.green <<~SUCCESS.chomp
      Successfully restored '#{branch}' from '#{backup_to_restore}'
    SUCCESS
  else
    STDERR.puts Term::ANSIColor.red <<~ERROR.chomp
      Failed to restore '#{branch}' from '#{backup_to_restore}'
    ERROR
    exit 1
  end
  exit 0
end

if options[:remote]
  backup_base = "#{branch}.bak.remote"
  source_branch = "#{options[:remote]}/#{branch}"

  unless source_exists?(branch, remote: options[:remote])
    STDERR.puts Term::ANSIColor.red <<~ERROR.chomp
      Remote branch '#{source_branch}' does not exist.
      Run 'git fetch' to update remote refs or check the branch name.
    ERROR
    exit 1
  end
else
  backup_base = "#{branch}.bak"
  source_branch = branch

  unless source_exists?(branch)
    STDERR.puts Term::ANSIColor.red <<~ERROR.chomp
      Branch '#{branch}' does not exist.
      Use 'git branch -a' to see available branches.
    ERROR
    exit 1
  end
end

# Build the full backup name with date and optional tag
def build_backup_name(base, date, count, tag)
  name = count > 0 ? "#{base}#{count + 1}" : base
  name += ".#{date}"
  name += tag if tag
  name
end

count = 0
max_tries = 50
backup_branch = nil
loop do
  backup_branch = build_backup_name(backup_base, todays_date, count, options[:tag])

  if branch_exists?(backup_branch)
    info Term::ANSIColor.bright_black <<~MESSAGE.chomp
      #{backup_branch} exists
    MESSAGE

    count += 1
    if count >= max_tries
      STDERR.puts Term::ANSIColor.red <<~ERROR.chomp
        Exhausted attempts to create a backup branch!
        You may need to do some cleanup.
      ERROR
      exit 1
    end
  else
    break
  end
end
command = "git branch #{Shellwords.escape(backup_branch)} #{Shellwords.escape(source_branch)}"
info command
if system(command)
  # In quiet mode, just output the backup branch name for scripting
  if $quiet
    puts backup_branch
  else
    puts Term::ANSIColor.green <<~SUCCESS.chomp
      Successfully backed up to #{backup_branch}
    SUCCESS
  end
else
  STDERR.puts Term::ANSIColor.red <<~ERROR.chomp
    Failed to backup #{source_branch} with command: #{command}
  ERROR
  exit 1
end
